\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}

\title{Core Concepts}

\begin{document}




\section{Core Concepts and Terminology}

This section introduces the key notions you will encounter when using the Hyperon Pattern Miner.  We illustrate with actual MeTTa functions and modules from the \texttt{hyperon-miner} repository.

\subsection{AtomSpace}

The \textbf{AtomSpace} is Hyperon's persistent metagraph store.  Every node and link you mine lives there.  In MeTTa you typically create or bind an AtomSpace via:

\begin{verbatim}
(import! &asm hyperon-experimental:AtomSpace)
(def atom-space (atomspace.new))
\end{verbatim}

Atoms you insert may be of various types, such as

\begin{itemize}
  \item \texttt{ConceptNode}: \verb|(concept "Coke")|
  \item \texttt{PredicateNode}: \verb|(pred    "drink")|
  \item \texttt{VariableNode}:  \verb|(var     "$X")|
  \item \texttt{InheritanceLink}: 
    \verb|(inherit (var "$X") (concept "American"))|
  \item \texttt{EvaluationLink}:  
    \verb|(eval (pred "drink") (list (var "$X") (concept "Coke")))|
\end{itemize}

\subsection{Abstract vs. Specialized Patterns}

The miner distinguishes between \emph{abstract} and \emph{specialized} patterns:

\begin{enumerate}

  \item \textbf{Abstract patterns}\\
   
    Generated by scanning link nodes and replacing one constant per link with a \texttt{VariableNode}.  Implemented by the \texttt{get-candidate} logic in \texttt{match/MinerMatch.metta}:
    \begin{verbatim}
;; returns a stream of 1-clause skeletons
(get-links atom-space)
(get-candidate 0 <link> minsup)
    \end{verbatim}

  \item \textbf{Specialized patterns}\\
    Each abstract pattern is ''specialized'' by composing it with shallow abstractions of its groundings (valuations).  This uses utilities in \texttt{utils/MinerUtils.metta} such as \texttt{specialize} and \texttt{support}.
\end{enumerate}

We now look at some examples of each of these.

\subsubsection{Abstract Patterns: One-Clause Skeleton Examples}

Below are two concrete examples showing how a ground link is turned into one-clause ?skeletons? by replacing each constant in turn with a variable.

\paragraph{Example 1: EvaluationLink}

Suppose the AtomSpace contains the ground atom:

\begin{verbatim}
(eval (pred "drink") (list (concept "Alice") (concept "Coke")))
\end{verbatim}

The one-clause skeletons generated by \texttt{get-links} are:

\begin{verbatim}
;; Replace subject with variable
(eval (pred "drink") (list (var "$X") (concept "Coke")))

;; Replace object with variable
(eval (pred "drink") (list (concept "Alice") (var "$X")))
\end{verbatim}

\paragraph{Example 2: InheritanceLink}

Given the ground atom:

\begin{verbatim}
(inherit (concept "Alice") (concept "American"))
\end{verbatim}

The one-clause skeletons are:

\begin{verbatim}
;; Replace instance with variable
(inherit (var "$X") (concept "American"))

;; Replace class with variable
(inherit (concept "Alice") (var "$X"))
\end{verbatim}


\subsubsection{Examples of Specialized Patterns}

Below are two concrete examples showing how an \texttt{abstract} pattern is turned into \texttt{specialized} candidate patterns via the \texttt{specialize} and \texttt{support} utilities.

\paragraph{Example 1: Single-Clause Drink Pattern}

Suppose your AtomSpace contains these ground atoms:
\begin{verbatim}
(eval (pred "drink") (list (concept "Alice") (concept "Coke")))
(eval (pred "drink") (list (concept "Bob")   (concept "Coke")))
(eval (pred "drink") (list (concept "Carol") (concept "Tea")))
\end{verbatim}

We can then

\begin{enumerate}
\item  Define the abstract pattern:
    \begin{verbatim}
    p_abs = (eval (pred "drink") (list (var "$X") (concept "Coke")))
    \end{verbatim}

\item  Specialize to get each grounding:
    \begin{verbatim}
    (specialize atom-space p_abs)
      => stream of
         (candidate
           (eval (pred "drink")
                 (list (concept "Alice") (concept "Coke")))
           1)
         (candidate
           (eval (pred "drink")
                 (list (concept "Bob")   (concept "Coke")))
           1)
    \end{verbatim}

\item   Group and count via support:
    \begin{verbatim}
    (support p_abs 2)
      => (candidate p_abs 2)
    \end{verbatim}
    This indicates the pattern ''\$X drinks Coke'' occurs twice.
\end{enumerate}

\paragraph{Example 2: Two-Clause Inheritance + Drink Pattern}

Now consider a 2-clause pattern combining inheritance and drink:

\begin{verbatim}
p2_abs = (and
            (inherit (var "$X") (concept "American"))
            (eval    (pred "drink")
                     (list (var "$X") (concept "Coke"))))
\end{verbatim}

Assume the AtomSpace also contains:
\begin{verbatim}
(inherit (concept "Alice") (concept "American"))
(inherit (concept "Bob")   (concept "American"))
(eval    (pred "drink")    (list (concept "Alice") (concept "Coke")))
(eval    (pred "drink")    (list (concept "Bob")   (concept "Coke")))
\end{verbatim}

We then


\begin{enumerate}
\item  Specialize to enumerate both groundings:
    \begin{verbatim}
    (specialize atom-space p2_abs)
      => stream of
         (candidate
           (and
             (inherit (concept "Alice") (concept "American"))
             (eval    (pred "drink")
                      (list (concept "Alice") (concept "Coke"))))
           1)
         (candidate
           (and
             (inherit (concept "Bob")   (concept "American"))
             (eval    (pred "drink")
                      (list (concept "Bob")   (concept "Coke"))))
           1)
    \end{verbatim}

\item  Filter by support threshold:
    \begin{verbatim}
    (support p2_abs 2)
      => (candidate p2_abs 2)
    \end{verbatim}
  -- indicating that ''Americans who drink Coke'' occurs for two distinct individuals.

\end{enumerate}

\subsection{Candidate Patterns and Support}

A \emph{candidate pattern} is any specialized pattern whose \emph{support} (match-count) meets your minimum threshold:

\begin{verbatim}
(= (get-candidate Z link-type minsup)
   (support (get-pattern (specialize link-type)) minsup))
\end{verbatim}

Here:
\begin{itemize}
  \item \texttt{minsup} is the minimum support parameter.
  \item \texttt{support} invokes \texttt{count} and filters out patterns with count < \texttt{minsup}.
\end{itemize}

\subsection{Conjunction and Pattern Expansion}

To discover richer structures, surviving patterns are greedily expanded by conjunction:

\begin{verbatim}
(= (get-candidate (S k) link-type minsup)
   (let* ((smaller (get-candidate k link-type minsup))
          (base    (get-candidate 0 link-type minsup))
          (comb    (combine-with
                     (get-pattern smaller)
                     (get-pattern base))))
     (support (flatten comb) minsup)))
\end{verbatim}

\texttt{combine-with} (in \texttt{utils/MinerUtils.metta}) pairs patterns that share variables to form multi-clause \verb|(and ...)| expressions.  Iterating with increasing depth yields N-clause patterns.

\subsection{Surprisingness (Interestingness)}

Once you have frequent $n$-clause patterns, you rank them by \emph{I-Surprisingness}, which measures how much a pattern?s observed probability deviates from its expected probability under a simple independence assumption.  

In more detail:

\begin{verbatim}
;; Compute I-Surprisingness of a pattern
(= (iSurprisingness pattern)
  ;; pattern = (candidate clauses count)
  (let* ((clauses   (get-clauses pattern))    ; list of atomic clauses
         (obs-count (get-count   pattern))    ; number of matches
         (Z         (universe-size))         ; total atoms
         (p_obs     (/ obs-count Z))         ; observed probability
         (p_exp     (compute-expected clauses Z))) ; expected under independence
    ;; return normalized absolute deviation
    (/ (abs (- p_obs p_exp))
       p_obs)))
;; Expected probability for 2-clause patterns:
(= (compute-expected (list c1 c2) Z)
  (* (/ (match-count c1) Z)
     (/ (match-count c2) Z)))
;; Expected probability for 3-clause patterns:
(= (compute-expected (list c1 c2 c3) Z)
  (let* ((p1    (/ (match-count c1) Z))
         (p2    (/ (match-count c2) Z))
         (p3    (/ (match-count c3) Z))
         ;; pairwise block probabilities
         (p12   (* p1 p2))
         (p13   (* p1 p3))
         (p23   (* p2 p3))
         ;; choose the most extreme block probability
         (p_max (max p12 p13 p23))
         (p_min (min p12 p13 p23)))
    ;; worst-case deviation from observed
    (max p_max p_min)))
\end{verbatim}

\paragraph{Explanation of steps}

\begin{enumerate}

  \item Compute \texttt{Z = universe-size}, the total number of atoms in the AtomSpace.


  \item For a pattern with support \texttt{obs-count}, compute its observed probability

        $$
          p_{\rm obs} = \frac{\texttt{obs-count}}{Z}.
        $$
  \item Compute the expected probability \texttt{p\_exp} by assuming each clause is independent:

  \begin{itemize}

    \item For two clauses $$(\{c_1,c_2\}\):

      $$
         p_{\rm exp} = P(c_1)\times P(c_2).
      $$

    \item For three clauses
            $${c_1,c_2,c_3}$$
            
            , consider the pairwise block probabilities
      $$ P(c_i)\,P(c_j) $$ for each pair, take the maximum and minimum of these, and use the one that yields the largest deviation.
  \end{itemize}
  \item Finally, compute the normalized absolute deviation
        $$
          I = \frac{\lvert p_{\rm obs} - p_{\rm exp}\rvert}{p_{\rm obs}}.
        $$
\end{enumerate}

You can then filter patterns by a surprisingness threshold \texttt{highsurp} using the high?level call:
\begin{verbatim}
(miner-surprising atom-space minsup max-clauses highsurp)
\end{verbatim}
which returns only those patterns with \(I >\) \texttt{highsurp}.

\end{document}