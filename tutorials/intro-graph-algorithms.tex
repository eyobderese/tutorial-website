\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}

\title{Introduction to Graph Algorithms}
\author{TutorialHub Team}
\date{May 15, 2023}
\keywords{Graphs, BFS, DFS, Algorithms}
\category{Algorithms}

\begin{document}

\maketitle

\begin{abstract}
Learn the fundamentals of graph theory and common algorithms. This tutorial covers basic definitions, graph representations, and key traversal algorithms like BFS and DFS.
\end{abstract}

\section{Introduction to Graph Algorithms}

Graphs are mathematical structures used to model pairwise relations between objects. A graph is made up of vertices (also called nodes) which are connected by edges.

\section{Basic Definitions}

A graph G is an ordered pair G = (V, E) where:
\begin{itemize}
  \item V is a set of vertices
  \item E is a set of edges, which are ordered or unordered pairs of vertices
\end{itemize}

\subsection{Types of Graphs}

\begin{itemize}
  \item \textbf{Undirected Graph}: Edges have no direction
  \item \textbf{Directed Graph}: Edges have direction
  \item \textbf{Weighted Graph}: Edges have weights/costs
\end{itemize}

\section{Graph Representation}

There are several ways to represent a graph:

\subsection{Adjacency Matrix}

An adjacency matrix is a square matrix used to represent a finite graph. The elements of the matrix indicate whether pairs of vertices are adjacent or not in the graph.

$$
A[i][j] = 
\begin{cases} 
1 & \text{if there is an edge from vertex i to vertex j} \\
0 & \text{otherwise}
\end{cases}
$$

\subsection{Adjacency List}

An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a vertex in the graph.

\begin{lstlisting}[language=python]
# Example of an adjacency list representation
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}
\end{lstlisting}

\section{Breadth-First Search (BFS)}

BFS is an algorithm for traversing or searching tree or graph data structures. It starts at a chosen node and explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.

\subsection{Algorithm}

\begin{enumerate}
  \item Start by putting any one of the graph's vertices at the back of a queue.
  \item Take the front item of the queue and add it to the visited list.
  \item Create a list of that vertex's adjacent nodes. Add the ones which aren't in the visited list to the back of the queue.
  \item Keep repeating steps 2 and 3 until the queue is empty.
\end{enumerate}

\begin{lstlisting}[language=python]
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)
    
    while queue:
        vertex = queue.popleft()
        print(vertex, end=" ")
        
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
\end{lstlisting}

\section{Depth-First Search (DFS)}

DFS is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node and explores as far as possible along each branch before backtracking.

\subsection{Algorithm}

\begin{enumerate}
  \item Start by putting any one of the graph's vertices on top of a stack.
  \item Take the top item of the stack and add it to the visited list.
  \item Create a list of that vertex's adjacent nodes. Add the ones which aren't in the visited list to the top of the stack.
  \item Keep repeating steps 2 and 3 until the stack is empty.
\end{enumerate}

\begin{lstlisting}[language=python]
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    print(start, end=" ")
    
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
\end{lstlisting}

\end{document}
